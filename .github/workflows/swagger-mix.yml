name: Swagger

on:
  push:
    branches: [ main ]
    paths:
      - "swagger/*.swagger.json"
      - ".github/workflows/swagger-mix.yml"

permissions: { contents: read }
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  merge:
    name: Merge files
    runs-on: ubuntu-latest
    permissions: { contents: write }
    steps:

      # TODO: use the hosted tool cache: @actions/tool-cache
      - name: Download go-swagger
        env:
          SWAGGER_VERSION: "0.32.3"
          OS_ARCH: "linux_amd64"

        run: |
          dir=$(mktemp -d)
          curl -sL "https://github.com/go-swagger/go-swagger/releases/download/v${SWAGGER_VERSION}/swagger_${OS_ARCH}" -o $dir/swagger
          sudo install $dir/swagger /usr/local/bin

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Deduplicate across all swagger files
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const swaggerDir = 'swagger';
            const files = fs.readdirSync(swaggerDir)
              .filter(f => f.endsWith('.swagger.json'))
              .map(f => path.join(swaggerDir, f));
            
            core.info(`ðŸ” Found ${files.length} swagger files`);

            const operationIds = {};
            const swaggerFiles = {};
            
            files.forEach(file => {
              const swagger = JSON.parse(fs.readFileSync(file, 'utf8'));
              swaggerFiles[file] = swagger;
            
              Object.entries(swagger.paths || {}).forEach(([pathKey, pathItem]) => {
                Object.entries(pathItem).forEach(([method, operation]) => {
                  if (operation.operationId) {
                    if (!operationIds[operation.operationId]) {
                      operationIds[operation.operationId] = [];
                    }
            
                    operationIds[operation.operationId].push({
                      file, pathKey, method, operation
                    });
                  }
                });
              });
            });
            
            const duplicates = [];
            Object.entries(operationIds).forEach(([opId, occurrences]) => {
              if (occurrences.length > 1) {
                occurrences.sort((a, b) => a.file.localeCompare(b.file));
            
                for (let i = 1; i < occurrences.length; i++) {
                  const occ = occurrences[i];
                  const suffix = occ.operation.tags?.[0] || (i + 1);
                  const newOpId = `${opId}_${suffix}`;
            
                  duplicates.push({
                    file: occ.file,
                    path: occ.pathKey,
                    method: occ.method,
                    oldId: opId,
                    newId: newOpId,
                    tag: occ.operation.tags?.[0] || 'N/A'
                  });
            
                  occ.operation.operationId = newOpId;
                }
              }
            });
            
            Object.entries(swaggerFiles).forEach(([file, swagger]) => {
              fs.writeFileSync(file, JSON.stringify(swagger, null, 2));
            });
            
            core.info(`âœ… Cross-file deduplication complete`);
            if (duplicates.length > 0) {
              core.warning(`Found ${duplicates.length} duplicate operationIds across files`);
              duplicates.forEach(dup => {
                core.warning(`Duplicate operationId: ${dup.oldId} â†’ ${dup.newId} (tag: ${dup.tag})`, {
                  file: dup.file,
                  title: `Duplicated operationId - ${dup.oldId}`
                });
              });
            } else {
              core.info(`âœ… No duplicates found across files!`);
            }

      - name: Merge Swagger files
        run: |
          set +e
          swagger mixin swagger/engine.swagger.json \
            swagger/storage.swagger.json \
            swagger/messages.swagger.json \
            swagger/logger.swagger.json \
            swagger/webitel-go.swagger.json \
            swagger/wfm.swagger.json \
            swagger/cases.swagger.json \
            swagger/fts.swagger.json \
            swagger/media-exporter.swagger.json \
            --output swagger/api.json
          
          EXIT_CODE=$?
          set -e
          
          if [ $EXIT_CODE -ne 0 ]; then
            echo "::warning::Swagger mixin finished with exit code $EXIT_CODE. Continuing as planned."
          fi

      - name: Check for local changes
        id: check-changes
        run: |
          if [ -n "$(git status --porcelain swagger/api.json)" ]; then
            echo "found=true" >> $GITHUB_OUTPUT

            echo "Uncommitted changes found in swagger/api.json: "
            git status --porcelain swagger/api.json
          fi

      - name: Create Github APP token
        uses: webitel/reusable-workflows/actions/create-github-app-token@create-github-app-token-v1.0.1
        if: steps.check-changes.outputs.found == 'true'
        id: app-token
        with:
          app-id: ${{ vars.DELIVERY_BOT_APP_ID }}
          private-key: ${{ secrets.DELIVERY_BOT_APP_PEM }}

      - name: Configure git user
        if: steps.check-changes.outputs.found == 'true'
        run: |
          git config --global user.name '${{ steps.app-token.outputs.user-name }}'
          git config --global user.email '${{ steps.app-token.outputs.user-email }}'
          git config --local --add --bool push.autoSetupRemote true

      - name: Commit changes
        if: steps.check-changes.outputs.found == 'true'
        run: |
          git add swagger/api.json
          git commit -m "chore: merge swagger files"
          git push
