syntax = "proto3";
package webitel.im.domain.thread.v1;


import "domain/thread/v1/peer.proto";

option go_package = "github.com/webitel/protos/messaging/thread/v1;impb";

// Enum representing available system message types.
// enum MessageType {
//     // Represents an unspecified or unknown message type.
//     UNSPECIFIED_MESSAGE_TYPE = 0;
//     // Represents a text message.
//     TEXT = 1;
//     // Represents a document message.
//     DOCUMENT = 2;
//     // Represents an image message.
//     IMAGE = 3;
// }

// message Document {
//   string id = 1;
//   string url = 2;
//   string file_name = 3; 
//   string mime_type = 4; 
//   int64 size_bytes = 5;
//   int64 created_at = 6;
//   string created_by = 7;
//   int64 updated_at = 8;
//   string updated_by = 9;
// }

// message Image {
//   string id = 1;
//   string url = 2;
//   string file_name = 3;
//   string mime_type = 4;

//   message Thumbnail {
//     string url = 1;
//   }
//   repeated Thumbnail thumbnails = 5;
//   int64 created_at = 6;
//   string created_by = 7;
//   int64 updated_at = 8;
//   string updated_by = 9;
// }

// message ThreadMessage {
//     string id = 1;
//     string thread_id = 2;
//     Peer from = 3;
//     Peer to = 4;

//     int64 created_at = 5;
//     int64 updated_at = 6;
//     string text = 7;
//     MessageType type = 8;
//     oneof content {
//         Document document = 9;
//         Image image = 10;
//     }
// }

// message SearchThreadMessagesHistoryRequest {
//   string thread_id = 1;
//   optional int64 cursor_timestamp = 2;
//   optional string cursor_id = 3;
//   int32 limit = 4;

//   repeated string peer_ids = 5;
//   repeated MessageType message_types = 6;
//   optional string q = 7;
//   repeated string ids = 8;
// }

// message SearchThreadMessagesHistoryResponse {
//     string thread_id = 1;
//     optional int64 last_cursor_timestamp = 2;
//     optional string last_cursor_id = 3;
//     bool has_next = 4;

//     repeated ThreadMessage messages = 5; 
// }

//----- !NEW CONTRACTS!
message HistoryMessageCursor {
  int64 created_at = 1;
  string id = 2[
    (buf.validate.field).string.uuid = true
  ];
  bool direction = 3;
}

message SearchMessageHistoryRequest {
  repeated string fields = 1;

  repeated string ids = 2;
  repeated string thread_ids = 3;
  repeated string sender_ids = 4;
  repeated string receiver_ids = 5;
  repeated int32 types = 6;

  optional HistoryMessageCursor cursor = 7;
  uint32 size = 8;
}

message DocumentDTO {
  string id = 1;
  string message_id = 2;
  int64 file_id = 3;
  string name = 4;
  string mime = 5;
  int64 size = 6;
  int64 created_at = 7;
}

message ImageDTO {
  string id = 1;
  string message_id = 2;
  int64 file_id = 3;
  string mime = 4;
  int32 width = 5;
  int32 height = 6;
  int64 created_at = 7;
}

message MessageDTO {
  string id = 1;
  string thread_id = 2;
  string sender_id = 3;
  string receiver_id = 4;
  int32 type = 5;
  string body = 6;
  map<string, google.protobuf.Any> metadata = 7;

  int64 created_at = 8;
  int64 updated_at = 9;

  repeated DocumentDTO documents = 10;
  repeated ImageDTO images = 11;
}

/*
 * @exclude
 * facebook cursor-based pagination example: https://stackoverflow.com/a/41475843  
 */

message Cursors {
  HistoryMessageCursor after = 1;
  HistoryMessageCursor before = 2;
}

message Paging {
  Cursors cursors = 1;
}

message SearchMessageHistoryResponse {
  repeated MessageDTO messages = 1;
  HistoryMessageCursor next_cursor = 2;
  bool next = 3;
  repeated string from = 4;
  Paging paging = 5;
}
